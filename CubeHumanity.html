<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CubeHumanity</title>
    <style>
        body {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            background-color: #f0f0f0;
            font-family: 'Courier New', Courier, monospace;
        }
        #simulation-container {
            position: relative;
            box-shadow: 0 0 20px rgba(0,0,0,0.1);
            border-radius: 8px;
            overflow: hidden;
        }
        canvas {
            display: block;
            background-color: #ffffff;
        }
        .ui-panel {
            position: absolute;
            top: 15px;
            background-color: rgba(255, 255, 255, 0.88);
            border-radius: 8px;
            padding: 15px;
            font-size: 14px;
            line-height: 1.5;
            color: #333;
            max-height: 95%;
            overflow-y: auto;
        }
        #info-panel {
            left: 15px;
            width: 150px;
            pointer-events: none;
        }
        #mutations-panel {
            right: 15px;
            width: 280px;
        }
        #mutations-panel h3 {
            margin-top: 0;
            margin-bottom: 10px;
            font-size: 16px;
            border-bottom: 1px solid #ccc;
            padding-bottom: 5px;
        }
        #mutations-list {
            list-style-type: none;
            padding: 0;
            margin: 0;
        }
        #mutations-list li {
            margin-bottom: 12px;
            font-size: 12px;
            line-height: 1.4;
            border-bottom: 1px solid #eee;
            padding-bottom: 8px;
            cursor: pointer;
        }
         #mutations-list li:hover {
            background-color: rgba(0,0,0,0.05);
        }
        .trait-title {
            font-weight: bold;
            font-size: 14px;
            margin-bottom: 4px;
        }
        .trait-combo {
            font-style: italic;
        }
        #controls {
            margin-top: 20px;
            display: flex;
            align-items: center;
            gap: 15px;
        }
        .input-group {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        #controls input {
            width: 60px;
            padding: 8px;
            border: 2px solid #ccc;
            border-radius: 8px;
            font-family: 'Courier New', Courier, monospace;
            font-size: 16px;
            text-align: center;
        }
        #restart-button {
            padding: 12px 24px;
            font-size: 16px;
            font-family: 'Courier New', Courier, monospace;
            font-weight: bold;
            color: #333;
            background-color: #fff;
            border: 2px solid #ccc;
            border-radius: 8px;
            cursor: pointer;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            transition: all 0.2s ease-in-out;
        }
        #restart-button:hover {
            background-color: #e9e9e9;
            transform: translateY(-2px);
            box-shadow: 0 6px 8px rgba(0,0,0,0.15);
        }
        #restart-button:active {
            transform: translateY(0);
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }
    </style>
</head>
<body>
    <div id="simulation-container">
        <canvas id="worldCanvas" width="1280" height="800"></canvas>
        <div id="info-panel" class="ui-panel">
            Total: <span id="population-count">0</span><br>
            Male: <span id="male-count">0</span><br>
            Female: <span id="female-count">0</span>
        </div>
        <div id="mutations-panel" class="ui-panel">
            <h3>Evolved Species</h3>
            <ul id="mutations-list"></ul>
        </div>
    </div>
    <div id="controls">
        <div class="input-group">
            <label for="male-start-input">Males:</label>
            <input type="number" id="male-start-input" value="1" min="0" max="25">
        </div>
        <div class="input-group">
            <label for="female-start-input">Females:</label>
            <input type="number" id="female-start-input" value="5" min="0" max="25">
        </div>
        <div class="input-group">
            <label for="food-spawn-input">Food %:</label>
            <input type="number" id="food-spawn-input" value="100" min="0" max="500" step="10">
        </div>
        <div class="input-group">
            <label for="speed-input">Speed %:</label>
            <input type="number" id="speed-input" value="100" min="10" max="500" step="10">
        </div>
        <button id="restart-button">Restart Simulation</button>
    </div>

    <script>
        const canvas = document.getElementById('worldCanvas');
        const ctx = canvas.getContext('2d');
        const populationCountSpan = document.getElementById('population-count');
        const maleCountSpan = document.getElementById('male-count');
        const femaleCountSpan = document.getElementById('female-count');
        const mutationsList = document.getElementById('mutations-list');
        const restartButton = document.getElementById('restart-button');
        const maleStartInput = document.getElementById('male-start-input');
        const femaleStartInput = document.getElementById('female-start-input');
        const foodSpawnInput = document.getElementById('food-spawn-input');
        const speedInput = document.getElementById('speed-input');

        const ARENA_WIDTH = canvas.width;
        const ARENA_HEIGHT = canvas.height;
        const MAX_CUBES = 100;
        const CUBE_SIZE = 30;
        const FOOD_SIZE = 5;
        
        const MUTATION_CATALOG = {
            'Jaw':          { tier: 0, cost: 1, maxLevel: 3, desc: "Eat More" },
            'Flagellum':    { tier: 0, cost: 2, maxLevel: 3, desc: "More Speed" },
            'Compound Eyes':{ tier: 1, cost: 2, maxLevel: 1, desc: "Better Vision" },
            'Spikes':       { tier: 1, cost: 2, maxLevel: 3, desc: "Damage Attacker" },
            'Fins':         { tier: 2, cost: 3, maxLevel: 3, desc: "Agile Swim" },
            'Escape Burst': { tier: 2, cost: 3, maxLevel: 1, desc: "Flee Prey" },
            'Wings':        { tier: 3, cost: 4, maxLevel: 3, desc: "Fly Fast" },
            'Carnivore':    { tier: 3, cost: 5, maxLevel: 1, desc: "Hunt Cubes" },
            'Toxicity':     { tier: 3, cost: 4, maxLevel: 3, desc: "Poison Attacker" }
        };

        let entities = [];
        let cubeCount = 0;
        let frameCount = 0;
        let selectedSpeciesKey = null;

        class Vector {
            constructor(x = 0, y = 0) { this.x = x; this.y = y; }
            add(v) { this.x += v.x; this.y += v.y; return this; }
            sub(v) { this.x -= v.x; this.y -= v.y; return this; }
            mult(s) { this.x *= s; this.y *= s; return this; }
            div(s) { if (s !== 0) { this.x /= s; this.y /= s; } return this; }
            mag() { return Math.sqrt(this.x * this.x + this.y * this.y); }
            normalize() { const m = this.mag(); if (m > 0) { this.div(m); } return this; }
            limit(max) { if (this.mag() > max) { this.normalize().mult(max); } return this; }
            clone() { return new Vector(this.x, this.y); }
            static sub(v1, v2) { return new Vector(v1.x - v2.x, v1.y - v2.y); }
            static dist(v1, v2) { return Vector.sub(v1, v2).mag(); }
        }

        class Cube {
            constructor(x, y, genes) {
                this.position = new Vector(x, y);
                this.velocity = new Vector(Math.random() * 2 - 1, Math.random() * 2 - 1);
                this.acceleration = new Vector(0, 0);
                this.gender = Math.random() < 0.5 ? 'male' : 'female';
                this.color = this.gender === 'male' ? 'rgba(0, 100, 255, 0.8)' : 'rgba(255, 105, 180, 0.8)';
                this.size = CUBE_SIZE;
                this.energy = 100;
                this.maxEnergy = 100;
                this.reproductionCooldown = 100;
                this.age = 0;
                this.escapeCooldown = 0;
                this.wanderAngle = 0;

                this.genes = genes || {
                    metabolicSpeed: Math.random() * 0.1 + 0.05,
                    sensoryRange: Math.random() * 100 + 50,
                    appendages: Math.random() * 2 + 1,
                    evolutionPoints: 1,
                    mutations: [],
                    lifespan: 6000 + Math.random() * 4000
                };
                
                this.applyGeneEffects();
                this.speciesKey = this.getSpeciesKey();
            }

            getSpeciesKey() {
                if (this.genes.mutations.length === 0) return 'Default';
                const sortedMutations = [...this.genes.mutations].sort((a,b) => a.type.localeCompare(b.type));
                return sortedMutations.map(m => `${m.type}${m.level}`).join('_');
            }

            hasMutation(type) {
                return this.genes.mutations.some(m => m.type === type);
            }

            getMutationLevel(type) {
                const mutation = this.genes.mutations.find(m => m.type === type);
                return mutation ? mutation.level : 0;
            }

            applyGeneEffects() {
                this.baseMaxSpeed = this.genes.appendages;
                this.maxSpeed = this.baseMaxSpeed;
                this.maxForce = 0.2;
                this.effectiveSensoryRange = this.genes.sensoryRange;
                this.effectiveMetabolism = this.genes.metabolicSpeed * 4;
                this.energyFromFood = 40;
                this.isCarnivore = this.hasMutation('Carnivore');

                this.genes.mutations.forEach(mutation => {
                    const level = mutation.level;
                    switch (mutation.type) {
                        case 'Jaw': this.energyFromFood += 15 * level; break;
                        case 'Exoskeleton':
                            this.baseMaxSpeed *= (1 - 0.15 * level);
                            this.effectiveMetabolism *= (1 - 0.2 * level);
                            break;
                        case 'Compound Eyes': this.effectiveSensoryRange *= (1 + 0.5 * level); break;
                        case 'Fins':
                            this.maxForce *= (1 + 0.2 * level);
                            this.baseMaxSpeed *= (1 + 0.1 * level);
                            break;
                        case 'Gills': this.effectiveMetabolism *= (1 - 0.25 * level); break;
                        case 'Wings':
                            this.baseMaxSpeed *= (1 + 0.4 * level);
                            this.effectiveMetabolism *= (1 + 0.2 * level);
                            break;
                        case 'Flagellum':
                            this.baseMaxSpeed *= (1 + 0.2 * level);
                            this.effectiveMetabolism *= (1 + 0.1 * level);
                            break;
                    }
                });
                this.maxSpeed = this.baseMaxSpeed;
            }

            applyForce(force) { this.acceleration.add(force); }

            seek(target) {
                if (!target) return new Vector(0,0);
                let desired = Vector.sub(target.position, this.position);
                desired.normalize().mult(this.maxSpeed);
                let steer = Vector.sub(desired, this.velocity);
                steer.limit(this.maxForce);
                return steer;
            }

            wander() {
                let wanderPoint = this.velocity.clone();
                wanderPoint.normalize();
                wanderPoint.mult(100);
                wanderPoint.add(this.position);

                let wanderRadius = 50;
                this.wanderAngle += (Math.random() * 0.5) - 0.25;

                let displacement = new Vector(
                    wanderRadius * Math.cos(this.wanderAngle),
                    wanderRadius * Math.sin(this.wanderAngle)
                );

                let wanderTarget = wanderPoint.add(displacement);
                return this.seek({ position: wanderTarget });
            }

            findNearest(items, range) {
                let closest = null;
                let closestDist = Infinity;
                for (const item of items) {
                    if (!item) continue;
                    let d = Vector.dist(this.position, item.position);
                    if (d < closestDist && d < range) {
                        closestDist = d;
                        closest = item;
                    }
                }
                return closest;
            }

            reproduce(partner, entities) {
                if (cubeCount >= MAX_CUBES || this.reproductionCooldown > 0 || partner.reproductionCooldown > 0) return;
                
                const epMutationChance = 0.1;
                const levelUpChance = 0.15;
                const newMutationChance = 0.05;

                let newEP = Math.random() < 0.5 ? this.genes.evolutionPoints : partner.genes.evolutionPoints;
                if (Math.random() < epMutationChance) newEP += 1;

                let availableEP = newEP;
                const finalMutations = [];
                const parentGenePool = [...this.genes.mutations, ...partner.genes.mutations];
                const uniqueParentGenes = parentGenePool.filter((gene, index, self) => 
                    index === self.findIndex(g => g.type === gene.type)
                ).map(g => ({...g, level: Math.max(this.genes.mutations.find(m=>m.type===g.type)?.level || 0, partner.genes.mutations.find(m=>m.type===g.type)?.level || 0)}));
                
                uniqueParentGenes.sort((a, b) => (MUTATION_CATALOG[b.type].cost * b.level) - (MUTATION_CATALOG[a.type].cost * a.level));

                for (const gene of uniqueParentGenes) {
                    let currentGene = {...gene};
                    
                    if (Math.random() < levelUpChance) {
                        currentGene.level = Math.min(currentGene.level + 1, MUTATION_CATALOG[currentGene.type].maxLevel);
                    }

                    const cost = MUTATION_CATALOG[currentGene.type].cost * currentGene.level;
                    if (availableEP >= cost) {
                        finalMutations.push(currentGene);
                        availableEP -= cost;
                    }
                }

                if (Math.random() < newMutationChance) {
                    const parentTiers = parentGenePool.map(m => MUTATION_CATALOG[m.type].tier);
                    const maxParentTier = parentTiers.length > 0 ? Math.max(...parentTiers) : -1;
                    const possibleNewTiers = Object.entries(MUTATION_CATALOG).filter(([type, data]) => data.tier <= maxParentTier + 1);
                    
                    const affordableNewMutations = possibleNewTiers.filter(([type, data]) => 
                        !finalMutations.some(m => m.type === type) && availableEP >= data.cost
                    );

                    if (affordableNewMutations.length > 0) {
                        const [type, data] = affordableNewMutations[Math.floor(Math.random() * affordableNewMutations.length)];
                        finalMutations.push({ type: type, level: 1 });
                    }
                }
                
                const newGenes = {
                    metabolicSpeed: (Math.random() < 0.5 ? this.genes.metabolicSpeed : partner.genes.metabolicSpeed) + (Math.random() - 0.5) * 0.1,
                    sensoryRange: (Math.random() < 0.5 ? this.genes.sensoryRange : partner.genes.sensoryRange) + (Math.random() - 0.5) * 50,
                    appendages: (Math.random() < 0.5 ? this.genes.appendages : partner.genes.appendages) + (Math.random() - 0.5) * 0.1,
                    evolutionPoints: newEP,
                    mutations: finalMutations,
                    lifespan: (Math.random() < 0.5 ? this.genes.lifespan : partner.genes.lifespan) + (Math.random() - 0.5) * 500
                };
                
                entities.push(new Cube(this.position.x, this.position.y, newGenes));

                this.reproductionCooldown = 300;
                partner.reproductionCooldown = 300;
                this.energy -= 40;
                partner.energy -= 40;
            }

            update(entities) {
                this.age++;
                if (this.escapeCooldown > 0) this.escapeCooldown--;

                const cubes = entities.filter(e => e instanceof Cube);
                const foods = entities.filter(e => e instanceof Food);

                // AI Logic
                const energyThreshold = 60;
                let target = null;

                if (this.energy < energyThreshold) {
                    // HUNGRY: Priority is food/prey. Normal speed.
                    this.maxSpeed = this.baseMaxSpeed;
                    if (this.isCarnivore) {
                        target = this.findNearest(cubes.filter(c => !c.isCarnivore), this.effectiveSensoryRange);
                    } else {
                        target = this.findNearest(foods, this.effectiveSensoryRange);
                    }
                } else {
                    // FULL: Priority is mate. Aggressive speed.
                    this.maxSpeed = this.baseMaxSpeed * 2.0;
                    let potentialMates;
                    if (this.isCarnivore) {
                        potentialMates = cubes.filter(c => c !== this && c.isCarnivore && c.gender !== this.gender && Vector.dist(this.position, c.position) < this.effectiveSensoryRange);
                    } else {
                        potentialMates = cubes.filter(c => c !== this && !c.isCarnivore && c.gender !== this.gender && Vector.dist(this.position, c.position) < this.effectiveSensoryRange);
                    }
                    
                    if (potentialMates.length > 0) {
                        potentialMates.sort((a, b) => b.genes.mutations.length - a.genes.mutations.length);
                        target = potentialMates[0];
                    }
                }

                // Prey escape logic can override the current target
                if (!this.isCarnivore) {
                    const nearestCarnivore = this.findNearest(cubes.filter(c => c.isCarnivore), this.effectiveSensoryRange);
                    if (nearestCarnivore && Vector.dist(this.position, nearestCarnivore.position) < this.effectiveSensoryRange / 2 && this.hasMutation('Escape Burst') && this.escapeCooldown === 0) {
                        this.energy -= 20;
                        this.escapeCooldown = 200;
                        const escapeVector = Vector.sub(this.position, nearestCarnivore.position);
                        this.velocity.add(escapeVector.normalize().mult(this.maxSpeed * 2));
                    }
                }

                if (target) {
                    this.applyForce(this.seek(target));
                } else {
                    // If no specific target, wander (speed is already set based on hunger)
                    this.applyForce(this.wander());
                }

                this.velocity.add(this.acceleration).limit(this.maxSpeed);
                this.position.add(this.velocity);
                this.acceleration.mult(0);

                this.energy -= this.effectiveMetabolism;
                if (this.reproductionCooldown > 0) this.reproductionCooldown--;

                // Bounce off walls
                const margin = this.size / 2;
                if (this.position.x <= margin) {
                    this.velocity.x *= -1;
                    this.position.x = margin;
                } else if (this.position.x >= ARENA_WIDTH - margin) {
                    this.velocity.x *= -1;
                    this.position.x = ARENA_WIDTH - margin;
                }
                if (this.position.y <= margin) {
                    this.velocity.y *= -1;
                    this.position.y = margin;
                } else if (this.position.y >= ARENA_HEIGHT - margin) {
                    this.velocity.y *= -1;
                    this.position.y = ARENA_HEIGHT - margin;
                }
            }

            draw(ctx) {
                const x = this.position.x;
                const y = this.position.y;
                
                const drawSize = this.speciesKey === selectedSpeciesKey ? this.size * 10 : this.size;

                // Draw main body
                ctx.fillStyle = this.speciesKey === selectedSpeciesKey ? 'black' : this.color;
                ctx.strokeStyle = 'rgba(0,0,0,0.5)';
                if(this.isCarnivore) ctx.strokeStyle = 'red';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.rect(x - drawSize / 2, y - drawSize / 2, drawSize, drawSize);
                ctx.fill();
                ctx.stroke();

                // Draw energy bar
                const energyPercentage = Math.max(0, this.energy / this.maxEnergy);
                const barWidth = drawSize;
                const barHeight = 4 * (drawSize / this.size);
                const barX = x - barWidth / 2;
                const barY = y - drawSize / 2 - barHeight - 2;
                
                ctx.fillStyle = '#ddd';
                ctx.fillRect(barX, barY, barWidth, barHeight);
                
                ctx.fillStyle = `hsl(${energyPercentage * 120}, 100%, 50%)`; // Green to Red
                ctx.fillRect(barX, barY, barWidth * energyPercentage, barHeight);

                ctx.strokeStyle = '#333';
                ctx.lineWidth = 1;
                ctx.strokeRect(barX, barY, barWidth, barHeight);

                // Draw age
                ctx.fillStyle = 'black';
                ctx.font = `${10 * (drawSize / this.size)}px 'Courier New'`;
                ctx.textAlign = 'center';
                ctx.fillText(this.age, x, barY - 5);


                // Draw mutations
                ctx.save();
                ctx.translate(x, y);
                ctx.rotate(Math.atan2(this.velocity.y, this.velocity.x));
                
                this.genes.mutations.forEach(mutation => {
                    const level = mutation.level;
                    switch (mutation.type) {
                        case 'Jaw':
                            ctx.fillStyle = 'black';
                            const jawOpenness = (Math.sin(frameCount * 0.3) + 1) / 2; // Oscillates between 0 and 1
                            const jawHeight = (2 + level) * 2 * (drawSize / this.size);
                            const jawWidth = 4 * 2 * (drawSize / this.size);
                            const maxSeparation = (1 + level) * 2 * (drawSize / this.size);
                            const separation = jawOpenness * maxSeparation;

                            // Upper jaw
                            ctx.fillRect(drawSize / 2, -jawHeight - separation, jawWidth, jawHeight);
                            // Lower jaw
                            ctx.fillRect(drawSize / 2, separation, jawWidth, jawHeight);
                            break;
                        case 'Spikes':
                            ctx.strokeStyle = 'black'; ctx.lineWidth = 1;
                            for(let i=0; i<level*2; i++){
                                let angle = (i/(level*2)) * Math.PI*2;
                                ctx.beginPath(); ctx.moveTo(Math.cos(angle)*(drawSize/2), Math.sin(angle)*(drawSize/2));
                                ctx.lineTo(Math.cos(angle)*(drawSize/2+3), Math.sin(angle)*(drawSize/2+3)); ctx.stroke();
                            }
                            break;
                        case 'Flagellum':
                            ctx.strokeStyle = this.color;
                            ctx.lineWidth = 2;
                            ctx.beginPath();
                            ctx.moveTo(-drawSize / 2, 0);
                            ctx.quadraticCurveTo(-drawSize, Math.sin(frameCount * 0.2) * (level * 2), -drawSize * (1 + level * 0.5), 0);
                            ctx.stroke();
                            break;
                    }
                });
                ctx.restore();
            }
        }

        class Food {
            constructor(x, y) { this.position = new Vector(x, y); this.size = FOOD_SIZE; this.color = 'rgba(255, 0, 0, 0.9)'; }
            draw(ctx) {
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.position.x, this.position.y, this.size, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        function spawnFood() {
            entities.push(new Food(Math.random() * ARENA_WIDTH, Math.random() * ARENA_HEIGHT));
        }
        function resetSimulation() {
            entities = [];
            frameCount = 0;
            
            const startMales = parseInt(maleStartInput.value) || 0;
            const startFemales = parseInt(femaleStartInput.value) || 0;

            for (let i = 0; i < startMales; i++) {
                const male = new Cube(Math.random() * ARENA_WIDTH, Math.random() * ARENA_HEIGHT);
                male.gender = 'male';
                male.color = 'rgba(0, 100, 255, 0.8)';
                entities.push(male);
            }

            for (let i = 0; i < startFemales; i++) {
                const female = new Cube(Math.random() * ARENA_WIDTH, Math.random() * ARENA_HEIGHT);
                female.gender = 'female';
                female.color = 'rgba(255, 105, 180, 0.8)';
                entities.push(female);
            }

            for (let i = 0; i < 30; i++) spawnFood();
        }

        function updateMutationsList(cubes) {
            const species = {};
            cubes.forEach(cube => {
                const key = cube.speciesKey;
                if (!species[key]) {
                    const text = cube.genes.mutations.length === 0 ? 'Default' : 
                        [...cube.genes.mutations]
                            .sort((a,b) => a.type.localeCompare(b.type))
                            .map(m => `${m.type} L${m.level} (${MUTATION_CATALOG[m.type].desc})`)
                            .join(', ');
                    species[key] = { count: 0, text: text, key: key, minAge: cube.age, maxAge: cube.age };
                }
                species[key].count++;
                species[key].minAge = Math.min(species[key].minAge, cube.age);
                species[key].maxAge = Math.max(species[key].maxAge, cube.age);
            });

            const sortedSpecies = Object.values(species).sort((a, b) => b.count - a.count);

            let mutationsHTML = '';
            sortedSpecies.forEach(data => {
                mutationsHTML += `<li data-species-key="${data.key}">
                    <div class="trait-title">Population: ${data.count}</div>
                    <div class="trait-combo">${data.text}</div>
                    <div>Age Range: ${data.minAge} - ${data.maxAge}</div>
                </li>`;
            });
            mutationsList.innerHTML = mutationsHTML;

            // Add event listeners for highlighting
            document.querySelectorAll('#mutations-list li').forEach(li => {
                li.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const key = li.dataset.speciesKey;
                    if (selectedSpeciesKey === key) {
                        selectedSpeciesKey = null; // Toggle off
                    } else {
                        selectedSpeciesKey = key; // Select new
                    }
                });
            });
        }
        
        function drawEnvironment(ctx) {
            const zoneHeight = ARENA_HEIGHT / 4;
            ctx.fillStyle = 'rgba(0, 0, 255, 0.05)';
            ctx.fillRect(0, 0, ARENA_WIDTH, zoneHeight);
            ctx.fillStyle = 'rgba(255, 0, 0, 0.05)';
            ctx.fillRect(0, ARENA_HEIGHT - zoneHeight, ARENA_WIDTH, zoneHeight);
            
            const wallThickness = 4;
            ctx.strokeStyle = 'teal';
            ctx.lineWidth = wallThickness;
            ctx.strokeRect(wallThickness / 2, wallThickness / 2, ARENA_WIDTH - wallThickness, ARENA_HEIGHT - wallThickness);
        }

        function animate() {
            ctx.clearRect(0, 0, ARENA_WIDTH, ARENA_HEIGHT);
            drawEnvironment(ctx);

            const speedPercentage = parseInt(speedInput.value) || 100;
            const simulationSteps = speedPercentage / 100;

            for (let step = 0; step < simulationSteps; step++) {
                frameCount++;

                const currentCubes = entities.filter(e => e instanceof Cube);
                cubeCount = currentCubes.length;
                
                const foodSpawnPercentage = parseInt(foodSpawnInput.value);
                if (isNaN(foodSpawnPercentage)) {
                    foodSpawnPercentage = 100;
                }
                const baseSpawnInterval = 100;
                const spawnInterval = foodSpawnPercentage > 0 ? baseSpawnInterval / (foodSpawnPercentage / 100) : Infinity;

                if (spawnInterval !== Infinity && frameCount % Math.round(spawnInterval) === 0) {
                    spawnFood();
                }
                
                for (let i = entities.length - 1; i >= 0; i--) {
                    const entity = entities[i];
                    if (entity instanceof Cube) {
                        entity.update(entities);
                        
                        if (entity.isCarnivore) {
                            for (let j = currentCubes.length - 1; j >= 0; j--) {
                                const prey = currentCubes[j];
                                if (prey && !prey.isCarnivore && Vector.dist(entity.position, prey.position) < entity.size) {
                                    const energyStolen = 50;
                                    prey.energy -= energyStolen;
                                    entity.energy += energyStolen;

                                    const spikeLevel = prey.getMutationLevel('Spikes');
                                    if (spikeLevel > 0) entity.energy -= 15 * spikeLevel;

                                    const toxicityLevel = prey.getMutationLevel('Toxicity');
                                    if (toxicityLevel > 0) entity.energy -= 20 * toxicityLevel;
                                }
                            }
                        } else {
                             for (let j = entities.length - 1; j >= 0; j--) {
                                if (entities[j] instanceof Food && Vector.dist(entity.position, entities[j].position) < entity.size) {
                                    entity.energy += entity.energyFromFood;
                                    entities.splice(j, 1);
                                }
                            }
                        }

                        entity.energy = Math.min(entity.energy, entity.maxEnergy); // Clamp energy

                        for (const other of currentCubes) {
                            if (entity.gender === 'female' && entity !== other && entity.gender !== other.gender && Vector.dist(entity.position, other.position) < entity.size * 1.5) {
                                entity.reproduce(other, entities);
                            }
                        }

                        if (entity.energy <= 0 || entity.age > entity.genes.lifespan) entities.splice(i, 1);
                    }
                }
            }
            
            const currentCubesForDraw = entities.filter(e => e instanceof Cube);
            const maleCount = currentCubesForDraw.filter(c => c.gender === 'male').length;
            const femaleCount = currentCubesForDraw.length - maleCount;
            
            populationCountSpan.textContent = currentCubesForDraw.length;
            maleCountSpan.textContent = maleCount;
            femaleCountSpan.textContent = femaleCount;

            if (frameCount % 30 === 0) {
                updateMutationsList(currentCubesForDraw);
            }

            // Draw non-selected entities first
            for (const entity of entities) {
                if(entity && (!entity.speciesKey || entity.speciesKey !== selectedSpeciesKey)) entity.draw(ctx);
            }
            // Draw selected entities on top
            for (const entity of entities) {
                if(entity && entity.speciesKey && entity.speciesKey === selectedSpeciesKey) entity.draw(ctx);
            }
            
            requestAnimationFrame(animate);
        }
        
        canvas.addEventListener('click', () => {
            selectedSpeciesKey = null;
        });
        restartButton.addEventListener('click', resetSimulation);
        resetSimulation();
        animate();
    </script>
</body>
</html>

